{"ast":null,"code":"import _defineProperty from \"C:/Users/Ronald/Desktop/Frontend/blog/myblog/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"C:/Users/Ronald/Desktop/Frontend/blog/myblog/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React from 'react';\nimport { useToken } from '../theme/internal';\nexport var responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\nvar getResponsiveMap = function getResponsiveMap(token) {\n  return {\n    xs: \"(max-width: \".concat(token.screenXSMax, \"px)\"),\n    sm: \"(min-width: \".concat(token.screenSM, \"px)\"),\n    md: \"(min-width: \".concat(token.screenMD, \"px)\"),\n    lg: \"(min-width: \".concat(token.screenLG, \"px)\"),\n    xl: \"(min-width: \".concat(token.screenXL, \"px)\"),\n    xxl: \"(min-width: \".concat(token.screenXXL, \"px)\")\n  };\n};\n/**\r\n * Ensures that the breakpoints token are valid, in good order\r\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\r\n */\nvar validateBreakpoints = function validateBreakpoints(token) {\n  var indexableToken = token;\n  var revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach(function (breakpoint, i) {\n    var breakpointUpper = breakpoint.toUpperCase();\n    var screenMin = \"screen\".concat(breakpointUpper, \"Min\");\n    var screen = \"screen\".concat(breakpointUpper);\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(\"\".concat(screenMin, \"<=\").concat(screen, \" fails : !(\").concat(indexableToken[screenMin], \"<=\").concat(indexableToken[screen], \")\"));\n    }\n    if (i < revBreakpoints.length - 1) {\n      var screenMax = \"screen\".concat(breakpointUpper, \"Max\");\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(\"\".concat(screen, \"<=\").concat(screenMax, \" fails : !(\").concat(indexableToken[screen], \"<=\").concat(indexableToken[screenMax], \")\"));\n      }\n      var nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      var nextScreenMin = \"screen\".concat(nextBreakpointUpperMin, \"Min\");\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(\"\".concat(screenMax, \"<=\").concat(nextScreenMin, \" fails : !(\").concat(indexableToken[screenMax], \"<=\").concat(indexableToken[nextScreenMin], \")\"));\n      }\n    }\n  });\n  return token;\n};\nexport default function useResponsiveObserver() {\n  var _useToken = useToken(),\n    _useToken2 = _slicedToArray(_useToken, 2),\n    token = _useToken2[1];\n  var responsiveMap = getResponsiveMap(validateBreakpoints(token));\n  // To avoid repeat create instance, we add `useMemo` here.\n  return React.useMemo(function () {\n    var subscribers = new Map();\n    var subUid = -1;\n    var screens = {};\n    return {\n      matchHandlers: {},\n      dispatch: function dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(function (func) {\n          return func(screens);\n        });\n        return subscribers.size >= 1;\n      },\n      subscribe: function subscribe(func) {\n        if (!subscribers.size) this.register();\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n      unsubscribe: function unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n        if (!subscribers.size) this.unregister();\n      },\n      unregister: function unregister() {\n        var _this = this;\n        Object.keys(responsiveMap).forEach(function (screen) {\n          var matchMediaQuery = responsiveMap[screen];\n          var handler = _this.matchHandlers[matchMediaQuery];\n          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);\n        });\n        subscribers.clear();\n      },\n      register: function register() {\n        var _this2 = this;\n        Object.keys(responsiveMap).forEach(function (screen) {\n          var matchMediaQuery = responsiveMap[screen];\n          var listener = function listener(_ref) {\n            var matches = _ref.matches;\n            _this2.dispatch(Object.assign(Object.assign({}, screens), _defineProperty({}, screen, matches)));\n          };\n          var mql = window.matchMedia(matchMediaQuery);\n          mql.addListener(listener);\n          _this2.matchHandlers[matchMediaQuery] = {\n            mql: mql,\n            listener: listener\n          };\n          listener(mql);\n        });\n      },\n      responsiveMap: responsiveMap\n    };\n  }, [token]);\n}","map":{"version":3,"names":["React","useToken","responsiveArray","getResponsiveMap","token","xs","screenXSMax","sm","screenSM","md","screenMD","lg","screenLG","xl","screenXL","xxl","screenXXL","validateBreakpoints","indexableToken","revBreakpoints","concat","reverse","forEach","breakpoint","i","breakpointUpper","toUpperCase","screenMin","screen","Error","length","screenMax","nextBreakpointUpperMin","nextScreenMin","useResponsiveObserver","responsiveMap","useMemo","subscribers","Map","subUid","screens","matchHandlers","dispatch","pointMap","func","size","subscribe","register","set","unsubscribe","paramToken","delete","unregister","Object","keys","matchMediaQuery","handler","mql","removeListener","listener","clear","_ref","matches","assign","window","matchMedia","addListener"],"sources":["C:/Users/Ronald/Desktop/Frontend/blog/myblog/node_modules/antd/es/_util/responsiveObserver.js"],"sourcesContent":["import React from 'react';\r\nimport { useToken } from '../theme/internal';\r\nexport const responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\r\nconst getResponsiveMap = token => ({\r\n  xs: `(max-width: ${token.screenXSMax}px)`,\r\n  sm: `(min-width: ${token.screenSM}px)`,\r\n  md: `(min-width: ${token.screenMD}px)`,\r\n  lg: `(min-width: ${token.screenLG}px)`,\r\n  xl: `(min-width: ${token.screenXL}px)`,\r\n  xxl: `(min-width: ${token.screenXXL}px)`\r\n});\r\n/**\r\n * Ensures that the breakpoints token are valid, in good order\r\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\r\n */\r\nconst validateBreakpoints = token => {\r\n  const indexableToken = token;\r\n  const revBreakpoints = [].concat(responsiveArray).reverse();\r\n  revBreakpoints.forEach((breakpoint, i) => {\r\n    const breakpointUpper = breakpoint.toUpperCase();\r\n    const screenMin = `screen${breakpointUpper}Min`;\r\n    const screen = `screen${breakpointUpper}`;\r\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\r\n      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);\r\n    }\r\n    if (i < revBreakpoints.length - 1) {\r\n      const screenMax = `screen${breakpointUpper}Max`;\r\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\r\n        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);\r\n      }\r\n      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\r\n      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;\r\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\r\n        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);\r\n      }\r\n    }\r\n  });\r\n  return token;\r\n};\r\nexport default function useResponsiveObserver() {\r\n  const [, token] = useToken();\r\n  const responsiveMap = getResponsiveMap(validateBreakpoints(token));\r\n  // To avoid repeat create instance, we add `useMemo` here.\r\n  return React.useMemo(() => {\r\n    const subscribers = new Map();\r\n    let subUid = -1;\r\n    let screens = {};\r\n    return {\r\n      matchHandlers: {},\r\n      dispatch(pointMap) {\r\n        screens = pointMap;\r\n        subscribers.forEach(func => func(screens));\r\n        return subscribers.size >= 1;\r\n      },\r\n      subscribe(func) {\r\n        if (!subscribers.size) this.register();\r\n        subUid += 1;\r\n        subscribers.set(subUid, func);\r\n        func(screens);\r\n        return subUid;\r\n      },\r\n      unsubscribe(paramToken) {\r\n        subscribers.delete(paramToken);\r\n        if (!subscribers.size) this.unregister();\r\n      },\r\n      unregister() {\r\n        Object.keys(responsiveMap).forEach(screen => {\r\n          const matchMediaQuery = responsiveMap[screen];\r\n          const handler = this.matchHandlers[matchMediaQuery];\r\n          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);\r\n        });\r\n        subscribers.clear();\r\n      },\r\n      register() {\r\n        Object.keys(responsiveMap).forEach(screen => {\r\n          const matchMediaQuery = responsiveMap[screen];\r\n          const listener = _ref => {\r\n            let {\r\n              matches\r\n            } = _ref;\r\n            this.dispatch(Object.assign(Object.assign({}, screens), {\r\n              [screen]: matches\r\n            }));\r\n          };\r\n          const mql = window.matchMedia(matchMediaQuery);\r\n          mql.addListener(listener);\r\n          this.matchHandlers[matchMediaQuery] = {\r\n            mql,\r\n            listener\r\n          };\r\n          listener(mql);\r\n        });\r\n      },\r\n      responsiveMap\r\n    };\r\n  }, [token]);\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}